---
title: "Types"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Types}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

vctrs uses the concept of a type, or prototype, rather than class in order to capture important additional attributes. As you will learn, this gives a clean separation between size and prototype and hence between recycling and type-coercion rules. 

```{r}
library(vctrs)
library(tibble)
```

## Type

A useful way to understand the high-level structure of a function is to think about its __type__. Instead of worrying about the specific values that are returned, we can just think about the classes[^class] involved. For example, if you `c()` together an integer and double vector you get a double vector. To express this more succinctly, we'll adopt a convention common in other programming langauges and write the class of the vector in angle brackets like `<integer>`, `<double>`. Then we can describe `c()` as `c(<integer>, <double>)` -> `<double>`.

[^class]: Here we'll ignore the distinction between the types of base vectors and the class of S3 vectors, using class to refer interchangeably to both.

Unfortunately, the `class()` of an object is inadequate for this purpose:

* The `class()` doesn't include attributes. Attributes are important because
  they store the levels of a factor, and the timezone of a `POSIXct`.
  
* The `class()` of a matrix is "matrix", and doesn't include the type of the
  underlying vector, or the number of columns.
  
Instead vctrs takes advantage of R's vectorised nature and uses a __prototype__, which is a 0-observation slice of the data structure. This is a miniature version of the vector that contains all of the attributes but none of the data. Conveniently, you can create many prototypes using existing base functions (e.g, `double()`, `factor(levels = c("a", "b"))`). 

### Prototypes

You can use `vec_type()` to create a prototype from an existing object. However, many base vectors have uninformative printing methods for 0-length subsets, so vctrs also provides `vec_ptype()`. `vec_ptype()` is designed for interactive exploration; it's called only for its side-effect of printing the prototype:

*  Atomic vectors are straightforward:

    ```{r}
    vec_ptype(FALSE)
    vec_ptype(1L)
    vec_ptype(2.5)
    vec_ptype("three")
    vec_ptype(list(1, 2, 3))
    ```

*  Matrices and arrays lose the first dimension as this is the size
   (and size and type are orthogonal by design).

    ```{r}
    vec_ptype(array(integer(), c(2, 3)))
    vec_ptype(array(character(), c(2, 3, 4)))
    ```

*  Factors have the levels attribute, a character vector. This can be 
   arbitrarily long so the prototype just shows a hash; if the hash of two
   factors is equal it's higly likely that their levels are also equal

    ```{r}
    vec_ptype(factor("a"))
    vec_ptype(ordered("b"))
    ```
    
    While printing only shows the hash, the prototype object itself does
    contain all levels:
    
    ```{r}
    vec_type(factor("a"))
    ```
    
*   Dates don't have any attributes, but date-times (`POSIXct`) have a 
    time zone and durations (`difftime`) have units.

    ```{r}
    vec_ptype(Sys.Date())
    vec_ptype(Sys.time())
    vec_ptype(as.difftime(10, units = "mins"))
    ```

*   Data frames have the most complex type: the type of a data frame is the 
    name and type of each column:
    
    ```{r}
    vec_ptype(data.frame(x = FALSE, y = 1L, z = 2.5))
    ```

    Data frames can have columns that are themselves data frames, making this
    a "recursive" type:
    
    ```{r}
    df <- data.frame(x = FALSE)
    df$y <- data.frame(a = 1L, b = 2.5)
    vec_ptype(df)
    ```

### Common types

Many functions need some way to find the common type from multiple inputs. vctrs provides `vec_type_common()` for this purpose. `vec_type_common()` possesses the following invariants:

* `class(vec_type_common(x, y))` equals `class(vec_type_common(y, x))`

* `class(vec_type_common(x, vec_type_common(y, z))` equals 
  `class(vec_type_common(vec_type_common(x, y)))` 
  
* `vec_type_common(x, NULL) == x`

i.e. `vec_type_common()` is both commutative and associative with respect to the class, and has an identity element, `NULL` . This makes it a __commutative monoid__, and means the underlying implementation is quite simple: we can find the common type of any number of any number of objects, by progressively finding the common type of pairs of elements. Under the hood, `vec_type_common()` is implemented with `vec_type2()`.

Like with `vec_type()`, the easiest way to explore `vec_type_common()` is with `vec_ptype()`: if you give it mulitple arguments it will show you the common prototype. (In other words: program with `vec_type_common()` but play with `vec_ptype()`.)

*   Matrices and arrays are automatically broadcast to higher dimensions:

    ```{r}
    vec_ptype(array(TRUE, c(2, 1)), array(1, c(5, 2)))
    vec_ptype(array(TRUE, c(1, 1)), array(1, c(1, 4, 3)))
    vec_ptype(TRUE, array(1, c(5, 10, 2)))
    ```

*   Factors combine levels in the order in which they appear.

    ```{r}
    fa <- factor("a")
    fb <- factor("b")
    
    levels(vec_type_common(fa, fb))
    levels(vec_type_common(fb, fa))
    ```

*   If the tzone is local, the other timezone wins. Otherwise the right-hand
    side wins.
    
    ```{r}
    vec_ptype(
      new_datetime(tzone = ""), 
      new_datetime(tzone = "Pacific/Auckland")
    )
    vec_ptype(
      new_datetime(tzone = "US/Central"), 
      new_datetime(tzone = "Pacific/Auckland")
    )
    ```

*   The common type of two data frames is the common type of each column that 
    occurs in both data frame frames, and the union of the columns that only 
    occur in one:

    ```{r}
    df1 <- data.frame(x = TRUE, y = 1L)
    df2 <- data.frame(x = 1, z = 1)
    vec_ptype(df1, df2)
    ```

    Note that new columns are added on the right-hand side.

### Casting

`vec_cast()` allows you to cast a value to a prototype, if possible. If a cast is possible in general (i.e. double -> integer), but information is lost for a specific input (e.g. 1.5 -> 1), it will generate a warning.

```{r, error = TRUE}
# Cast succeeds
vec_cast(c(1, 2), integer())

# Cast loses information
vec_cast(c(1.5, 2), integer())

# Cast fails
vec_cast(c(1.5, 2.5), factor("a"))
```

If you simply want to coerce multiple vectors to the same type, you can use `vec_cast_common()`:

```{r}
str(vec_cast_common(x = 1:4, y = FALSE, z = 2.5))
```

`vec_cast_common()` is a wrapper around `vec_type_common()` and `vec_cast()`.


## Size

`vec_size()` was motivated by the need to have a invariant that describes the number of "observations" in a data structure. This particularly important for data frames as we want to be able to say `vec_size(data.frame(x))` equals `vec_size(x)`. No base function has this property:

* `length(data.frame(x))` equals `1`, because the length of a data frame 
   is the number of columns.

* `nrow(data.frame(x))` does not equal `nrow(x)`, because `nrow()` of a 
  vector is `NULL`.

* `NROW(data.frame(x))` equals `NROW(x)` for vector `x`, so is almost what
  we want. But because `NROW()` is defined in terms of `length()`, it returns
  a value for every object, even types that can't go in a data frame, e.g.
  `data.frame(mean)` errors even though `NROW(mean)` is `1`.

Given `vec_size()`, we can give a precise definition of a data frame: a data frame is a list of vectors where every element has the same size. This has the desirable property of trivially supporting matrix and data frame columns.

### Slicing

`vec_slice()` is to `vec_size()` as `[` is to `length()`; i.e. it allows you to select observations, regardless of the dimensionality of the underlying object. 

```{r}
x <- sample(1:10)
df <- data.frame(x = x)

vec_slice(x, 5:6)
vec_slice(df, 5:6)
```

`vec_slice(data.frame(x), i)` equals `data.frame(vec_slice(x, i))` (modulo variable and row names).

### Common sizes: recycling rules

Many functions need some way to find the common type from multiple inputs.

Closely related to the definition of size are the __recycling rules__. The recycling rules determine the length of the output when two vectors of different lengths are combined. In vctrs, the recycling rules are encoded in `vec_size_common()` which give the common size of a set of vectors:

```{r}
vec_size_common(1:3, 1:3, 1:3)
vec_size_common(1:10, 1)
vec_size_common(integer(), 1:3)
```

vctrs obeys a stricter set of recylcing rules than base R, only recycling under two circumstances:

* Vectors of length 1 can be recycled to any length.
* Vectors of any length can be recylced to length 0.

All other combinations of lengths will generate an error. 

```{r, echo = FALSE, fig.cap="Summary of vctrs recycling rules"}
knitr::include_graphics("../man/figures/sizes-recycling.png", dpi = 300)
```

This strictness prevents common mistakes like `dest == c("IAH", "HOU"))` at the cost of requiring explicit calls to `rep()` when occassionally needed.

### Manual recycling

You can apply the recycling rules in two ways:

*   If you have a vector and desired size, use `vec_recycle()`:

    ```{r}
    vec_recycle(1:3, 3)
    vec_recycle(1, 10)
    vec_recycle(1:3, 0)
    ```
    
*  If you have multiple vectors and you want to recycle them to the same
   length, use `vec_recycle_common()`:

    ```{r}
    vec_recycle_common(1:3, 1:3)
    vec_recycle_common(1:10, 1)
    vec_recycle_common(integer(), 1:3)
    ```
    
    `vec_recycle_common()` is a wrapper around `vec_size_common()` and
    `vec_recycle()`.
   
## Appendix: recycling in base R

The recycling rules in base R are described in [The R Language Definition](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Recycling-rules) but are not implemented in a single function, and thus are not applied consistently. Here I give a brief overview of their most common realisation, as well as showing some of the exceptions.

Generally, in base R, when a pair of vectors is not the same length, the shorter vector is recycled to the same length as the longer:

```{r}
rep(1, 6) + 1
rep(1, 6) + 1:2
rep(1, 6) + 1:3
```

If the length of the longer vector is not an integer multiple of the length of the shorter, you usually get a warning:

```{r}
invisible(pmax(1:2, 1:3))
invisible(1:2 + 1:3)
invisible(cbind(1:2, 1:3))
```

But some functions recycle silently:

```{r}
length(atan2(1:3, 1:2))
length(paste(1:3, 1:2))
length(ifelse(1:3, 1:2, 1:2))
```

And `data.frame()` throws an error:

```{r, error = TRUE}
data.frame(1:2, 1:3)
```

The R language definition states that "any arithmetic operation involving a zero-length vector has a zero-length result". But outside of arithmetic, this rule is not consistently followed:

```{r, error = TRUE}
# length-0 output
1:2 + integer()
atan2(1:2, integer())
pmax(1:2, integer())

# dropped
cbind(1:2, integer())

# recycled to length of first
ifelse(rep(TRUE, 4), integer(), character())

# preserved-ish
paste(1:2, integer())

# Errors
data.frame(1:2, integer())
```
