---
title: "Sizes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Sizes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(1014)
```

vctrs uses the concept of size, rather than length, because it better captures what you typically care about when doing a data analysis: the number of observations. This gives a clean separation between size and prototype and hence between recycling and type-coercion rules. 

```{r setup}
library(vctrs)
library(tibble)
```

## Motivation

`vec_size()` was motivated by the need to have a invariant that describes the number of "observations" in a data structure. This particularly important for data frames as we want to be able to say `vec_size(data.frame(x))` equals `vec_size(x)`. No base function has this property:

* `length(data.frame(x))` equals `1`, because the length of a data frame 
   is the number of columns.

* `nrow(data.frame(x))` does not equal `nrow(x)`, because `nrow()` of a 
  vector is `NULL`.

* `NROW(data.frame(x))` equals `NROW(x)` for vector `x`, so is almost what
  we want. But because `NROW()` is defined in terms of `length()`, it returns
  a value for every object, even types that can't go in a data frame, e.g.
  `data.frame(mean)` errors even though `NROW(mean)` is `1`.

Given `vec_size()`, we can give a precise definition of a data frame: a data frame is a list of vectors where every element has the same size. This has the desirable property of trivially supporting matrix and data frame columns.

## Slicing

`vec_slice()` is to `vec_size()` as `[` is to `length()`; i.e. it allows you to select observations, regardless of the dimensionality of the underlying object. 

```{r}
x <- sample(1:10)
df <- data.frame(x = x)

vec_slice(x, 5:6)
vec_slice(df, 5:6)
```

`vec_slice(data.frame(x), i)` equals `data.frame(vec_slice(x, i))` (modulo variable and row names).

## vctrs recycling rules

Closely related to the definition of size are the __recycling rules__. The recycling rules determine the length of the output when two vectors of different lengths are combined. In vctrs, the recycling rules are encoded in `vec_size_common()` which give the common size of a set of vectors:

```{r}

vec_size_common(1:3, 1:3, 1:3)
vec_size_common(1:10, 1)
vec_size_common(integer(), 1:3)
```

vctrs obeys a stricter set of recylcing rules than base R, only recycling under two circumstances:

* Vectors of length 1 can be recycled to any length.
* Vectors of any length can be recylced to length 0.

All other combinations of lengths will generate an error. 

```{r, echo = FALSE, fig.cap="Summary of vctrs recycling rules"}
knitr::include_graphics("../man/figures/sizes-recycling.png", dpi = 300)
```

This strictness prevents common mistakes like `dest == c("IAH", "HOU"))` at the cost of requiring explicit calls to `rep()` when occassionally needed.

## Base R recycling rules

The recycling rules in base R are described in [The R Language Definition](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Recycling-rules) but these rules are only applied consistently for arithmetic operations. Here I give a brief overview of their most common realisation, as well as showing some of the exceptions.

Generally, in base R, when a pair of vectors is not the same length, the shorter vector is recycled to the same length as the longer:

```{r}
rep(1, 6) + 1
rep(1, 6) + 1:2
rep(1, 6) + 1:3
```

If the size of the longer vector is not an integer multiplier of the size of the smaller, you often get a warning:

```{r}
invisible(pmax(1:2, 1:3))
invisible(1:2 + 1:3)
invisible(cbind(1:2, 1:3))
```

But other functions recycle silently:

```{r}
length(atan2(1:3, 1:2))
length(paste(1:3, 1:2))
length(ifelse(1:3, 1:2, 1:2))
```

And `data.frame()` throws an error:

```{r, error = TRUE}
data.frame(1:2, 1:3)
```

The R language definition states that "any arithmetic operation involving a zero-length vector has a zero-length result."

There is even greater variety if one of the vectors is length 0:

```{r, error = TRUE}
# length-0 output
atan2(1:2, integer())
pmax(1:2, integer())
1:2 + integer()

# dropped
cbind(1:2, integer())

# recycled to length of longest
ifelse(rep(TRUE, 4), integer(), character())

# preserved-ish
paste(1:2, integer())

# Errors
data.frame(1:2, integer())
```
