---
title: "Double dispatch"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Double dispatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


The implementation of `vec_type2()` relies on __[double dispatch](https://en.wikipedia.org/wiki/Double_dispatch)__, because the result depends on the type of both arguments. S3 does not natively support double dispatch, but we can implement with a trick: doing single dispatch twice. 

It looks like this: `vec_type2()` is a generic funtion, and the method it calls is _also_ a generic:

```{r, eval = FALSE}
vec_type2 <- function(x, y) {
  UseMethod("vec_type2")
}
vec_type2.integer <- function(x, y) {
  UseMethod("vec_type2.integer", y)
}
vec_type2.integer.double <- function(x, y) {
  double()
}
```

To make this a bit more concrete, when you call `vec_type2(1L, 1)` the sequence of calls is:

* `vec_type2()`
* `vec_type2.integer()`
* `vec_type2.integer.double()`

If you call `vec_type2(1, 1L)` the sequence of calls is quite different:

* `vec_type2()`
* `vec_type2.double()`
* `vec_type2.double.integer()`

In order to preserve commutativity, `vec_type2.x.y()` __must__ return the same value as `vec_type2.y.x()`. Unfortunately there's no way to enforce this at the language level, so instead we use strong conventions (always defining the pair of methods next to each other) and unit tests to make sure that we're consistent.

## Namespaces

Defining S3 method interactively is fine for iteration and exploration, but if your vector lives in a package, you also need to register the S3 methods by listing them in the `NAMESPACE` file. The namespace declarations are a little tricky because (e.g.) `vec_cast.binned()` is both a generic function (which must be exported with `export()`) and an S3 method (which must be registered with `S3method()`). 

This problem wasn't considered in the design of roxygen2, so you have to be quite explicit:

```{r}
#' @export
#' @method vec_cast binned
#' @export vec_cast.binned
vec_cast.binned <- function(x, y) {
} 
```

You also need to register the individual double-dispatch methods. Unfortuantely roxygen's heuristic for determing the name of the generic from the name of the method gives the wrong result here, so you need to fully specify it:

```{r}
#' @method vec_cast.binned double
#' @export
vec_cast.binned.double <- function(x, y) {
}
```

Hopefully future versions of roxygen will make these exports less painful.
