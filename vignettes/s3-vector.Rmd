---
title: "S3 vectors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{S3 vectors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette contains tips for creating your own S3 vector class built on top the `vctr` class provided by vctrs. It focusses on the aspects of making a vector class that every class needs to worry about; you'll also need to provide methods that actually make the vector useful.

```{r}
library(vctrs)
```

## My first class: `percent()`

We'll first work through the simplest possible class: one that just changes how the output is printed. The following sections will show more complicated examples once you have this under your belt.

### Low-level constructor

All classes should have a low-level constructor called `new_class()` that checks types (but not values), then calls `new_vctr()`.  This function is designed for developers: it should be high performance (i.e. no expensive checks) so it can be called from other functions.

```{r, error = TRUE}
new_percent <- function(x) {
  stopifnot(is.double(x))
  
  new_vctr(x, class = "percent")
}

x <- new_percent(c(seq(0, 1, length = 4), NA))
str(x)
```

### Formatter

We can inspect this object, but we can't easily print it:

```{r, error = TRUE}
x
```

You should always provide a `format()` method:

```{r}
format.percent <- function(x, ...) {
  out <- format.default(signif(unclass(x) * 100, 3))
  out[!is.na(x)] <- paste0(out[!is.na(x)], "%")
  out
}
```

```{r, include = FALSE}
vctrs:::register_s3_method("base", "format", "percent")
```

```{r}
x
```

This is all you need for a function vector as the vctr base class provides many default methods with reasonable behaviour.

```{r}
x[1:2]

x[0]

x[[1]]

rep(x, 2)

-x

sqrt(x)
```

### User-friendly constructor

Next, implement a user friendly constructor called `myclass()`. It should carefully check that the input is valid, providing human readable messages if it is not:

```{r}
percent <- function(x = double()) {
  # Check invariants
  if (!is.numeric(x)) {
    stop("Percentages must be numeric", call. = FALSE)
  }

  # Strip attributes and names
  x <- as.double(x)
  attributes(x) <- NULL

  new_percent(x)
}
```

When called with no arguments the construct should return a zero-length vector.

```{r}
percent()
```

### Casting

```{r}
vec_cast.percent <- function(x, to) UseMethod("vec_cast.percent")
vec_cast.percent.default <- function(x, to) stop_incompatible_cast(x, to)
vec_cast.percent.NULL    <- function(x, to) x
vec_cast.NULL.percent    <- function(x, to) x
vec_cast.percent.numeric <- function(x, to) percent(x)
vec_cast.numeric.percent <- function(x, to) vec_data(x)
vec_cast.percent.percent <- function(x, to) x
```
```{r, include = FALSE}
vctrs:::register_s3_method("vctrs", "vec_cast", "percent")
```

Now `[[<-` and `[<-` will work:

```{r, error = TRUE}
x[1] <- 2
x

x[[1]] <- "x"
```

Note that vctrs explicitly forbid use of `$`.

```{r, error = TRUE}
x$a
x$a <- 1
```

### Coercion

```{r}
vec_type2.percent <- function(x, y) UseMethod("vec_cast.percent")
vec_type2.percent.default <- function(x, y) stop_incompatible_type(x, y)
vec_type2.percent.NULL    <- function(x, y) percent()
vec_type2.NULL.percent    <- function(x, y) percent()
vec_type2.percent.numeric <- function(x, y) percent()
vec_type2.numeric.percent <- function(x, y) percent()
vec_type2.percent.percent <- function(x, y) percent()
```
```{r, include = FALSE}
vctrs:::register_s3_method("vctrs", "vec_type2", "percent")
```

```{r}
vec_c(x, 1)

x == 1
x * 2
```

Unfortunately

```{r}
x * factor("x")
factor("x") * x
```

### Data frames and tibbles

```{r}
data.frame(x)
```

To make work more nicely in tibbles, provide a method for 
`pillar::type_sum()`:

```{r}
type_sum.percent <- function(x) {
  "pctv"
}

tibble::tibble(x)
```

```{r, include = FALSE}
vctrs:::register_s3_method("pillar", "type_sum", "percent")
```

For greater control over printing, you'll need to provide a
`pillar::pillar_shaft()`. A full discussion of this method is beyond the scope of this text, because tibble columns have functionality to grow and shrink to fill available space. See the details in: 
<https://tibble.tidyverse.org/articles/extending.html>.

